def extended_gcd(a, b):
    """
    Реализация расширенного алгоритма Евклида с выводом промежуточных шагов.
    Возвращает gcd(a, b) и коэффициенты x, y такие, что ax + by = gcd(a, b).
    """
    steps = []  # Для сохранения промежуточных шагов
    if a == 0:
        return b, 0, 1, steps  # Если a равно 0, возвращаем b как НОД, x и y равные 0 и 1, пустой список шагов
    else:
        gcd, x1, y1, prev_steps = extended_gcd(b % a, a)  # Рекурсивный вызов с новыми значениями b % a и a
        x = y1 - (b // a) * x1  # Расчет коэффициента x
        y = x1  # Расчет коэффициента y
        steps = prev_steps + [(a, b, x, y)]  # Добавление текущего шага к промежуточным шагам
        return gcd, x, y, steps  # Возвращаем НОД и коэффициенты x, y, а также промежуточные шаги

def solve_linear_congruence(a, b, m):
    """
    Решает сравнение ax ≡ b (mod m) и выводит все возможные решения или сообщает о их отсутствии.
    """
    gcd, x, y, steps = extended_gcd(a, m)  # Получаем НОД и коэффициенты x, y из расширенного алгоритма Евклида
    solutions = []

    if b % gcd != 0:
        return f"Сравнение не имеет решений, так как gcd({a}, {m}) = {gcd} не делит {b}.", steps  # Если b не делится на НОД, возвращаем сообщение о отсутствии решений

    x0 = (x * (b // gcd)) % m  # Расчет частного от деления b на НОД и последующее умножение на коэффициент x
    for i in range(gcd):
        solutions.append((x0 + i * (m // gcd)) % m)  # Добавляем возможные решения в список

    if len(solutions) == 1:
        return f"Уникальное решение: x ≡ {solutions[0]} (mod {m})", steps  # Если есть только одно решение, возвращаем его
    else:
        return f"Множество решений: {' '.join([f'x ≡ {sol} (mod {m})' for sol in solutions])}", steps  # Возвращаем множество решений, если их несколько

print(solve_linear_congruence(14, 30, 100))  
